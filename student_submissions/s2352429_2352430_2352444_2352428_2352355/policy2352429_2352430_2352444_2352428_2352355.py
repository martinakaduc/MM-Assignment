from policy import Policy
import numpy as np

class Policy2352429_2352430_2352444_2352428_2352355(Policy):
    def __init__(self,policy_id=1):
        # Student code here
        """
        Lư Thuận Hưng: Lead Developer for the genetic approach to the cutting-stock problem. Analyzed performance data, and recommended final improvements.
        Thượng Đình Hưng: Prepared the final report, summarized the theoretical research, implementation, testing, and results.
        Lưu Đại Hưng: Assisted in the development of the Genetic approach to the cutting-stock problem.
        Lê Mạnh Hưng: Researched the overall background information and objective of the project.
        Nguyễn Văn Hoàng: Developed Skyline approach to cutting-stock problem.
        """
        
        """
        Initialize the policy with parameters for the genetic algorithm.
        Args:
            population_size (int): Number of chromosomes in the population.
            penalty (float): Penalty factor for unsatisfied demand.
            mutation_rate (float): Probability of mutation for a chromosome.
        """
        assert policy_id in [1, 2], "Policy ID must be 1 or 2"
        self.policy_id = policy_id  # Store the policy ID
        if policy_id == 1:
            self.area_used_stock = 0
            self.skylines = []
            self.area_used = 0
            self.stock_used = 0
            self.stocks = []
        elif policy_id == 2:
            self.MAX_ITERATIONS = 100  # Maximum number of iterations for the genetic algorithm.
            self.POPULATION_SIZE = 50
            self.stock_length = 0
            self.stock_width = 0
            self.l_arr = []  # List of product lengths.
            self.w_arr = []  # List of product widths.
            self.d_arr = []  # List of product demands.
            self.N = None  # Number of products.
            self.penalty = 2
            self.mutation_rate = 0.01
    
    def get_action(self, observation, info):
        """
        Decide which implementation of get_action to use based on policy_id.
        """
        if self.policy_id == 1:
            return self.get_action_skyline(observation, info)
        elif self.policy_id == 2:
            return self.get_action_genetic(observation, info)
    
    #Genetic Algorithm
    def generate_efficient_patterns_2(self):
        """
        Generate efficient patterns for the 2D cutting stock problem.
        The patterns determine how many of each product can fit into a stock piece.

        Returns:
            result (list): List of efficient patterns, where each pattern is a list
                          representing the counts of each product that can fit.
        """
        result = []
        # Initialize the combination array
        A_arr = [
            min(
                (self.stock_length // self.l_arr[0]),
                (self.stock_width // self.w_arr[0]),
                self.d_arr[0]
            )
        ]

        for n in range(1, self.N):
            # Compute the maximum number of product `n` that can fit.
            s_length = sum([A_arr[j] * self.l_arr[j] for j in range(n)])
            s_width = sum([A_arr[j] * self.w_arr[j] for j in range(n)])
            max_repeat = min(
                (self.stock_length - s_length) // self.l_arr[n],
                (self.stock_width - s_width) // self.w_arr[n],
                self.d_arr[n]
            )
            A_arr.append(max_repeat)

        while True:
            result.append(A_arr)

            # Find the first index that can be decremented to generate a new pattern.
            for j in range(self.N - 2, -1, -1):
                if A_arr[j] > 0:
                    k = j
                    break
            else:
                # No more patterns can be generated.
                return result

            # Generate new combination by decrementing `A_arr[k]`.
            A_arr_new = []
            for j in range(k):
                A_arr_new.append(A_arr[j])
            A_arr_new.append(A_arr[k] - 1)

            for n in range(k + 1, self.N):
                s_length = sum([A_arr_new[j] * self.l_arr[j] for j in range(n)])
                s_width = sum([A_arr_new[j] * self.w_arr[j] for j in range(n)])
                max_repeat = min(
                    (self.stock_length - s_length) // self.l_arr[n],
                    (self.stock_width - s_width) // self.w_arr[n],
                    self.d_arr[n]
                )
                A_arr_new.append(max_repeat)

            A_arr = A_arr_new

    def calculate_max_pattern_repetition_2(self, patterns_arr):
        """
        Calculate the maximum number of repetitions for each pattern to meet demands.

        Args:
            patterns_arr (list): List of patterns generated by `generate_efficient_patterns_2`.

        Returns:
            result (list): Maximum number of repetitions for each pattern.
        """
        result = []
        for pattern in patterns_arr:
            max_rep = 0
            for i in range(len(pattern)):
                if pattern[i] > 0:
                    needed_rep = np.ceil(self.d_arr[i] / pattern[i])
                    if needed_rep > max_rep:
                        max_rep = needed_rep
            result.append(max_rep)
        return result

    def initialize_population_2(self, max_repeat_arr):
        """
        Initialize the population of chromosomes.

        Args:
            max_repeat_arr (list): Maximum number of repetitions for each pattern.

        Returns:
            init_population (list): Initial population of chromosomes.
        """
        init_population = []
        # Create the priority based on the weight (length + width) x random
        weighted_priority = [
            (j, (self.l_arr[j] + self.w_arr[j]) * np.random.random()) for j in range(len(self.l_arr))
        ]
        # Sort the weight list by descending
        weighted_priority.sort(key=lambda x: -x[1])
        indices = [item[0] for item in weighted_priority]  # Take the indice after sort

        for i in range(self.POPULATION_SIZE):
            chromosome = []
            # Randomly shuffle half the list
            np.random.shuffle(indices[: len(indices) // 2])
            
            for j in indices:
                chromosome.append(j)
                chromosome.append(np.random.randint(0, max_repeat_arr[j]))
            init_population.append(chromosome)

        return init_population


    def evaluate_fitness_2(self, chromosome, patterns_arr):
        """
        Evaluate the fitness of a chromosome.

        Args:
            chromosome (list): The chromosome to evaluate.
            patterns_arr (list): List of efficient patterns.

        Returns:
            fitness (float): Fitness score of the chromosome.
        """
        P = self.penalty  # Penalty for unmet demand.
        unsupplied_sum = 0  # Total unmet demand penalty.
        l_provided = [0] * self.N  # Tracks provided quantities for each product.
        total_waste = 0  # Tracks waste material.

        # Ensure valid stock dimensions.
        if self.stock_length == 0 or self.stock_width == 0:
            raise ValueError("Stock dimensions (length or width) are invalid.")

        # Compute stock area.
        stock_area = max(1, self.stock_length * self.stock_width)

        # Calculate product supply and waste.
        for i in range(0, len(chromosome), 2):
            pattern_idx = chromosome[i]
            repetition = chromosome[i + 1]
            pattern = patterns_arr[pattern_idx]

            # Update product quantities.
            for j in range(len(pattern)):
                l_provided[j] += pattern[j] * repetition

            # Approximate waste calculation.
            total_waste += stock_area * repetition - len(pattern) * repetition

        # Calculate unmet demand penalty.
        for i in range(self.N):
            num_unsupplied = max(0, self.d_arr[i] - l_provided[i])
            unsupplied_sum += num_unsupplied * self.l_arr[i]

        # Compute fitness using adjusted weights.
        fitness = (
            0.8 * (1 - total_waste / stock_area)  # Favor waste reduction.
            - 0.2 * (P * unsupplied_sum / sum(self.d_arr))  # Penalize unmet demand.
        )

        return fitness

    @staticmethod
    def select_parents_2(fitness_pairs):
        """
        Select two parent chromosomes based on fitness rank and randomness.

        Args:
            fitness_pairs (list): List of tuples (chromosome, fitness).

        Returns:
            (tuple): Two selected parent chromosomes.
        """
        n = len(fitness_pairs)
        max_val1 = max_val2 = float('-inf')
        index1 = index2 = None

        for i in range(n):
            # Calculate weighted score based on rank and randomness.
            pattern_area = fitness_pairs[i][1]
            score = (n - i) * np.random.random() * pattern_area

            # Select two highest-scoring chromosomes.
            if score > max_val1:
                max_val1, max_val2 = score, max_val1
                index1, index2 = i, index1
            elif score > max_val2:
                max_val2 = score
                index2 = i

        return fitness_pairs[index1][0], fitness_pairs[index2][0]

    @staticmethod
    def crossover_2(parent1, parent2):
        """
        Perform crossover between two parent chromosomes to generate offspring.

        Args:
            parent1 (list): First parent chromosome.
            parent2 (list): Second parent chromosome.

        Returns:
            (tuple): Two offspring chromosomes.
        """
        if parent1 is None or parent2 is None:
            raise ValueError("Parent is None")

        n = len(parent1)
        # Select two random crossover points
        point1_options = [i for i in range(0, n)]
        point1_index = np.random.choice(point1_options)
        point2_options = [i for i in range(point1_index, n)]
        point2_index = np.random.choice(point2_options)

        # Generate children using crossover points.
        child1 = parent1[:point1_index] + parent2[point1_index: point2_index] + parent1[point2_index:]
        child2 = parent2[:point1_index] + parent1[point1_index: point2_index] + parent2[point2_index:]
        return child1, child2

    def mutate_2(self, chromosome, max_repeat_arr):
        """
        Perform mutation on a chromosome by modifying repetition values.

        Args:
            chromosome (list): Chromosome to mutate.
            max_repeat_arr (list): Maximum repetitions for each pattern.

        Returns:
            chromosome (list): Mutated chromosome.
        """
        for i in range(1, len(chromosome), 2):
            if np.random.random() < 1 / self.stock_length:
                repeat = max_repeat_arr[chromosome[i - 1]]
                chromosome[i] = np.random.randint(0, repeat)
        return chromosome

    def run(self, population, patterns_arr, max_repeat_arr, problem_path):
        """
        Run the Genetic Algorithm to solve the 2D cutting stock problem.

        Args:
            population (list): Initial population of chromosomes.
            patterns_arr (list): List of feasible patterns.
            max_repeat_arr (list): Maximum repetitions for each pattern.
            problem_path (str): Problem instance file path (not used directly here).
            queue (Queue, optional): Queue for communication during execution.

        Returns:
            tuple: Best solution, its fitness, fitness history, and execution time.
        """
        best_results = []
        num_iters_same_result = 0
        last_result = float('inf')
        iter_cnt = self.MAX_ITERATIONS

        # Calculate stock area
        if self.stock_length == 0 or self.stock_width == 0:
            raise ValueError("Stock dimensions (length or width) are not initialized properly.")
        stock_area = self.stock_length * self.stock_width

        for count in range(self.MAX_ITERATIONS):
            # Evaluate fitness for the population
            fitness_pairs = [(ch, self.evaluate_fitness_2(ch, patterns_arr)) for ch in population]
            fitness_pairs.sort(key=lambda x: x[1], reverse=True)

            # Track the best result
            best_solution, best_fitness = fitness_pairs[0]
            best_results.append(best_fitness)

            # Convergence check
            if abs(best_fitness - last_result) < 1e-5:
                num_iters_same_result += 1
            else:
                num_iters_same_result = 0
            last_result = best_fitness

            # Early termination if converged
            if num_iters_same_result >= 100 or best_fitness == 1:
                iter_cnt = count
                break

            # Preserve top 3 (elitism)
            next_generation = [fitness_pairs[i][0] for i in range(3)]

            # Create new population
            while len(next_generation) < self.POPULATION_SIZE:
                parent1, parent2 = self.select_parents_2(fitness_pairs)  # Parent selection
                child1, child2 = self.crossover_2(parent1, parent2)  # Crossover
                child1, child2 = self.crossover_2(parent1, parent2)
                child1 = self.mutate_2(child1, max_repeat_arr)
                child2 = self.mutate_2(child2, max_repeat_arr)
                next_generation.append(child1)
                next_generation.append(child2)

            # Update population for the next iteration
            population = next_generation[:self.POPULATION_SIZE]

        return best_solution, best_fitness, best_results

    def get_action_genetic(self, observation, info):
        list_prods = observation["products"]
        stocks = observation["stocks"]

        # Ensure there are stocks available
        if not stocks or not list_prods:
            return {"stock_idx": -1, "size": [0, 0], "position": (0, 0)}

        # Extract product dimensions and demands
        self.l_arr = [prod["size"][0] for prod in list_prods if prod["quantity"] > 0]
        self.w_arr = [prod["size"][1] for prod in list_prods if prod["quantity"] > 0]
        self.d_arr = [prod["quantity"] for prod in list_prods if prod["quantity"] > 0]
        self.N = len(self.l_arr)

        if self.N == 0:
            return {"stock_idx": -1, "size": [0, 0], "position": (0, 0)}

        # Initialize stock dimensions using the first stock in the list
        first_stock = stocks[0]
        self.stock_length, self.stock_width = self._get_stock_size_(first_stock)

        # Generate patterns and initialize population
        patterns_arr = self.generate_efficient_patterns_2()
        max_repeat_arr = self.calculate_max_pattern_repetition_2(patterns_arr)
        population = self.initialize_population_2(max_repeat_arr)

        # Run the genetic algorithm
        best_solution, _, _ = self.run(population, patterns_arr, max_repeat_arr, None)

        # Translate best solution to a placement action
        for i in range(0, len(best_solution), 2):
            pattern_index = best_solution[i]
            repetition = best_solution[i + 1]
            pattern = patterns_arr[pattern_index]

            for stock_idx, stock in enumerate(stocks):
                stock_w, stock_h = self._get_stock_size_(stock)
                for x in range(stock_w):
                    for y in range(stock_h):
                        if pattern_index >= len(self.l_arr):
                            continue  # Skip invalid pattern indices
                        prod_size = (self.l_arr[pattern_index], self.w_arr[pattern_index])   

                        if self._can_place_(stock, (x, y), prod_size):
                            return {
                                "stock_idx": stock_idx,
                                "size": prod_size,
                                "position": (x, y)
                            }

        return {"stock_idx": -1, "size": [0, 0], "position": (0, 0)}

    
    
    
    #Skyline Heuristic
    class SkylineSegment():
        def __init__(self, x_start, x_end, height) -> None:
            self.x_end = x_end
            self.x_start = x_start
            self.height = height

        def calculate_local_waste(self, prod_size, prod_pos) -> int:
            prod_x_start, prod_y = prod_pos
            prod_w, prod_h = prod_size
            prod_x_end = prod_x_start + prod_w

            if (prod_x_end <= self.x_start): return 0
            if (prod_x_start >= self.x_end): return 0
            a = (prod_y - self.height)
            b = (min(prod_x_end, self.x_end))
            c = (max(prod_x_start, self.x_start))
            return a * (b - c)

        def intersects(self, prod_size, prod_pos) -> bool:
            prod_w, prod_h = prod_size
            prod_x_start, prod_y = prod_pos
            prod_x_end = prod_x_start + prod_w

            if prod_x_end <= self.x_start or prod_x_start >= self.x_end or prod_y >= self.height:
                return False

            return True

    def init_skyline_set(self, stock_list):
        # this will initialize the skyline set
        self.skylines = []

        self.stocks = [(stock, i) for i, stock in enumerate(stock_list)]
        self.stocks.sort(key=lambda x: -(self._get_stock_size_(x[0])[0] * self._get_stock_size_(x[0])[1]))

        i = 0
        while i < len(self.stocks):
            stock, idx = self.stocks[i]
            self.skylines.append([Policy2352429_2352430_2352444_2352428_2352355.SkylineSegment(0, self._get_stock_size_(stock)[0], 0)])
            i += 1

    def calculate_minimum_local_waste(self, product, stock, stock_idx):
        stock_w, stock_h = self._get_stock_size_(stock)
        prod_w, prod_h = product["size"]

        WONT_USE = 1e18

        waste_area = WONT_USE
        placement_choice = (-1, -1)
        should_rotate = False

        def calculate_waste(prod_w, prod_h, pos_x, pos_y):
            current_waste_area = 0
            for each_part in self.skylines[stock_idx]:
                current_waste_area += each_part.calculate_local_waste((prod_w, prod_h), (pos_x, pos_y))
            return current_waste_area

        def check_valid_placement(prod_w, prod_h, pos_x, pos_y):
            if pos_x < 0 or pos_x + prod_w > stock_w: return False
            if pos_y < 0 or pos_y + prod_h > stock_h: return False
            if not self._can_place_(stock, (pos_x, pos_y), (prod_w, prod_h)): return False
            for part in self.skylines[stock_idx]:
                if part.intersects((prod_w, prod_h), (pos_x, pos_y)):
                    return False
            return True

        for part in self.skylines[stock_idx]:
            for pos_x, pos_y in [(part.x_start, part.height), (part.x_end - prod_w, part.height)]:
                if check_valid_placement(prod_w, prod_h, pos_x, pos_y):
                    current_waste_area = calculate_waste(prod_w, prod_h, pos_x, pos_y)
                    if waste_area > current_waste_area:
                        waste_area = current_waste_area
                        placement_choice = (pos_x, pos_y)
                        should_rotate = False

        prod_w, prod_h = prod_h, prod_w

        for part in self.skylines[stock_idx]:
            for pos_x, pos_y in [(part.x_start, part.height), (part.x_end - prod_w, part.height)]:
                if check_valid_placement(prod_w, prod_h, pos_x, pos_y):
                    current_waste_area = calculate_waste(prod_w, prod_h, pos_x, pos_y)
                    if waste_area > current_waste_area:
                        waste_area = current_waste_area
                        placement_choice = (pos_x, pos_y)
                        should_rotate = True

        return int(waste_area), placement_choice, should_rotate

    def place_product(self, product, pos, stock, stock_idx):
        new_skyline = []

        prod_w, prod_h = product["size"]
        pos_x, pos_y = pos
        x_start = int(pos_x)
        x_end = int(x_start + prod_w)
        height = pos_y + prod_h

        new_skyline.append(Policy2352429_2352430_2352444_2352428_2352355.SkylineSegment(x_start, x_end, height))

        i = 0
        while i < len(self.skylines[stock_idx]):
            other_part = self.skylines[stock_idx][i]
            if other_part.x_end <= x_start or other_part.x_start >= x_end:
                new_skyline.append(other_part)
            else:
                if other_part.x_start < x_start:
                    new_skyline.append(Policy2352429_2352430_2352444_2352428_2352355.SkylineSegment(other_part.x_start, x_start, other_part.height))
                if other_part.x_end > x_end:
                    new_skyline.append(Policy2352429_2352430_2352444_2352428_2352355.SkylineSegment(x_end, other_part.x_end, other_part.height))
            i += 1

        new_skyline.sort(key=lambda x: x.x_start)
        self.skylines[stock_idx] = new_skyline

    def get_action_skyline(self, observation, info):
        # Student code here
        if info['filled_ratio'] == 0.0:
            # the env have been reset
            self.init_skyline_set(observation["stocks"])

        list_prods = observation["products"]
        list_prods = sorted(list_prods, key=lambda x: -(x["size"][0] * x["size"][1]))

        for prod in list_prods:
            if prod["quantity"] == 0:
                continue

            place = self.find_best_placement(prod, observation["stocks"])
            if place:
                self.area_used += prod["size"][0] * prod["size"][1]
                return place

    def find_best_placement(self, prod, stocks):
        prod_size = prod["size"]
        if prod_size[0] < prod_size[1]:
            prod_size[0], prod_size[1] = prod_size[1], prod_size[0]

        waste_area, (pos_x, pos_y) = 1e18, (-1, -1)
        stock_idx_choice = -1
        should_rotate = False

        i = 0
        while i < len(self.stocks):
            stock, stock_idx = self.stocks[i]
            if i >= self.stock_used:
                break

            current_waste_area, (tmp_x, tmp_y), tmp_rotate = self.calculate_minimum_local_waste(prod, stock, stock_idx)
            if current_waste_area < waste_area:
                waste_area = current_waste_area
                pos_x, pos_y = tmp_x, tmp_y
                stock_idx_choice = stock_idx
                should_rotate = tmp_rotate
                break
            i += 1

        if waste_area == 1e18:
            stock_idx_choice, pos_x, pos_y, should_rotate = self.use_new_stock(prod)

        if should_rotate:
            prod_size[0], prod_size[1] = prod_size[1], prod_size[0]
        self.place_product(prod, (pos_x, pos_y), stocks[stock_idx_choice], stock_idx_choice)
        return {"stock_idx": stock_idx_choice, "size": prod_size, "position": (pos_x, pos_y)}

    def find_best_placement_in_existing_stocks(self, prod):
        waste_area, (pos_x, pos_y) = 1e18, (-1, -1)
        stock_idx_choice = -1
        should_rotate = False

        for i, (stock, stock_idx) in enumerate(self.stocks):
            if i >= self.stock_used:
                break

            current_waste_area, (tmp_x, tmp_y), tmp_rotate = self.calculate_minimum_local_waste(prod, stock, stock_idx)
            if current_waste_area < waste_area:
                waste_area = current_waste_area
                pos_x, pos_y = tmp_x, tmp_y
                stock_idx_choice = stock_idx
                should_rotate = tmp_rotate

        return waste_area, (pos_x, pos_y), stock_idx_choice, should_rotate

    def find_best_placement(self, prod, stocks):
        prod_size = prod["size"]
        if prod_size[0] < prod_size[1]:
            prod_size[0], prod_size[1] = prod_size[1], prod_size[0]

        waste_area, (pos_x, pos_y), stock_idx_choice, should_rotate = self.find_best_placement_in_existing_stocks(prod)

        if waste_area == 1e18:
            stock_idx_choice, pos_x, pos_y, should_rotate = self.use_new_stock(prod)

        if should_rotate:
            prod_size[0], prod_size[1] = prod_size[1], prod_size[0]
        self.place_product(prod, (pos_x, pos_y), stocks[stock_idx_choice], stock_idx_choice)
        return {"stock_idx": stock_idx_choice, "size": prod_size, "position": (pos_x, pos_y)}

    def use_new_stock(self, prod):
        while True:
            self.stock_used += 1
            stock_w, stock_h = self._get_stock_size_(self.stocks[self.stock_used - 1][0])
            self.area_used_stock += stock_w * stock_h

            current_waste_area, (tmp_x, tmp_y), tmp_rotate = self.calculate_minimum_local_waste(prod, self.stocks[self.stock_used - 1][0], self.stocks[self.stock_used - 1][1])
            if current_waste_area < 1e18:
                return self.stocks[self.stock_used - 1][1], tmp_x, tmp_y, tmp_rotate